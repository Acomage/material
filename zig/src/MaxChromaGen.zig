const std = @import("std");
const io = std.Options.debug_io;
const hct = @import("Hct/HctSolver.zig");
const maxChroma = hct.maxChromaBuildTime;
const maxChroma2 = hct.maxChromaBuildTime2;
const MaxChromaAndArgb = hct.MaxChromaAndArgb;
const ySingular = hct.ySingular;
const yLowerEpsilon = hct.yLowerEpsilon;
const yUpperEpsilon = hct.yUpperEpsilon;

pub const peak = struct {
    tone: f32,
    chroma: f32,
};

fn findPeak(hue: f32) peak {
    var a: f32 = 0.5;
    var b: f32 = 98.5;
    const phi = (@sqrt(5.0) - 1.0) / 2.0;
    var c = b - phi * (b - a);
    var d = a + phi * (b - a);
    var fc = maxChroma(hue, @as(f32, c));
    var fd = maxChroma(hue, @as(f32, d));
    while (b - a > 0.0001) {
        if (fc < fd) {
            a = c;
            c = d;
            fc = fd;
            d = a + phi * (b - a);
            fd = maxChroma(hue, @as(f32, d));
        } else {
            b = d;
            d = c;
            fd = fc;
            c = b - phi * (b - a);
            fc = maxChroma(hue, @as(f32, c));
        }
    }
    const tone = (a + b) / 2.0;
    const chroma = maxChroma(hue, @as(f32, tone));
    return peak{
        .tone = tone,
        .chroma = chroma,
    };
}

fn generatePeak() [720]peak {
    var lut: [720]peak = undefined;
    for (0..720) |i| {
        const hue = @as(f32, @floatFromInt(i)) / 2.0;
        lut[i] = findPeak(hue);
    }
    return lut;
}

fn generateMaxChromaLUT() [100][360]MaxChromaAndArgb {
    var lut: [100][360]MaxChromaAndArgb = undefined;
    const step = (ySingular - yUpperEpsilon - yLowerEpsilon) / 99.0;
    var y: f32 = yLowerEpsilon;
    for (0..100) |i| {
        y = yLowerEpsilon + step * @as(f32, @floatFromInt(i));
        for (0..360) |hueInt| {
            const hue = @as(f32, @floatFromInt(hueInt));
            lut[i][hueInt] = maxChroma2(hue, y);
        }
    }
    return lut;
}

fn writeZigFile(out_path: []const u8, peaklut: [720]peak, maxChromaLut: [100][360]MaxChromaAndArgb) !void {
    const cwd: std.Io.Dir = std.Io.Dir.cwd();

    const file: std.Io.File = try cwd.createFile(io, out_path, .{
        .truncate = true,
    });
    defer file.close(io);

    var fw = file.writer(io, &.{});
    const w = &fw.interface;

    try w.writeAll(
        \\// AUTO-GENERATED by MaxChromaGen.zig. DO NOT EDIT.
        \\// Regenerate via: zig build gen-maxchroma
        \\
        \\pub const peak = struct {
        \\    tone: f32,
        \\    chroma: f32,
        \\};
        \\pub const MaxChromaAndArgb = struct {
        \\    chroma: f32,
        \\    argb: u32,
        \\};
        \\
        \\pub const maxChromaPeak: [720]peak = .{
        \\
    );

    for (peaklut, 0..) |p, idx| {
        try w.print("    .{{ .tone = {d:.10}, .chroma = {d:.10} }}", .{ p.tone, p.chroma });
        if (idx + 1 != peaklut.len) {
            try w.writeAll(",\n");
        } else {
            try w.writeAll("\n");
        }
    }

    try w.writeAll("};\n");

    try w.writeAll(
        \\
        \\pub const maxChromaLUT: [100][360]MaxChromaAndArgb = .{
        \\
    );

    for (maxChromaLut, 0..) |row, row_idx| {
        try w.writeAll("    .{");
        for (row, 0..) |value, col_idx| {
            try w.print(".{{  .chroma = {d:.10}, .argb = {d} }}", .{ value.chroma, value.argb });
            if (col_idx + 1 != row.len) {
                try w.writeAll(", ");
            }
        }
        try w.writeAll(" }");
        if (row_idx + 1 != maxChromaLut.len) {
            try w.writeAll(",\n");
        } else {
            try w.writeAll("\n");
        }
    }

    try w.writeAll("};\n");
}

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    if (args.len != 2) {
        std.debug.print("usage: {s} <output-path>\n", .{args[0]});
        return error.InvalidArgs;
    }

    const out_path = args[1];
    const peaklut = generatePeak();
    const maxChromaLut = generateMaxChromaLUT();
    try writeZigFile(out_path, peaklut, maxChromaLut);
}
