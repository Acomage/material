const std = @import("std");
const io = std.Options.debug_io;
const hct = @import("Hct/HctSolver.zig");
const maxChroma = hct.maxChroma;

pub const peak = struct {
    tone: f32,
    chroma: f32,
};

fn findPeak(hue: f32) peak {
    var a: f32 = 0.5;
    var b: f32 = 98.5;
    const phi = (@sqrt(5.0) - 1.0) / 2.0;
    var c = b - phi * (b - a);
    var d = a + phi * (b - a);
    var fc = maxChroma(hue, @as(f32, c));
    var fd = maxChroma(hue, @as(f32, d));
    while (b - a > 0.0001) {
        if (fc < fd) {
            a = c;
            c = d;
            fc = fd;
            d = a + phi * (b - a);
            fd = maxChroma(hue, @as(f32, d));
        } else {
            b = d;
            d = c;
            fd = fc;
            c = b - phi * (b - a);
            fc = maxChroma(hue, @as(f32, c));
        }
    }
    const tone = (a + b) / 2.0;
    const chroma = maxChroma(hue, @as(f32, tone));
    return peak{
        .tone = tone,
        .chroma = chroma,
    };
}

fn generateLut() [720]peak {
    var lut: [720]peak = undefined;
    for (0..720) |i| {
        const hue = @as(f32, @floatFromInt(i)) / 2.0;
        lut[i] = findPeak(hue);
    }
    return lut;
}

fn writeZigFile(out_path: []const u8, lut: [720]peak) !void {
    const cwd: std.Io.Dir = std.Io.Dir.cwd();

    const file: std.Io.File = try cwd.createFile(io, out_path, .{
        .truncate = true,
    });
    defer file.close(io);

    var fw = file.writer(io, &.{});
    const w = &fw.interface;

    try w.writeAll(
        \\// AUTO-GENERATED by MaxChromaGen.zig. DO NOT EDIT.
        \\// Regenerate via: zig build gen-maxchroma
        \\
        \\pub const peak = struct {
        \\    tone: f32,
        \\    chroma: f32,
        \\};
        \\
        \\pub const maxChromaPeak: [720]peak = .{
        \\
    );

    for (lut, 0..) |p, idx| {
        try w.print("    .{{ .tone = {d:.10}, .chroma = {d:.10} }}", .{ p.tone, p.chroma });
        if (idx + 1 != lut.len) {
            try w.writeAll(",\n");
        } else {
            try w.writeAll("\n");
        }
    }

    try w.writeAll("};\n");
}

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    if (args.len != 2) {
        std.debug.print("usage: {s} <output-path>\n", .{args[0]});
        return error.InvalidArgs;
    }

    const out_path = args[1];
    const lut = generateLut();
    try writeZigFile(out_path, lut);
}
